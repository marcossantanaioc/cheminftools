[
  {
    "objectID": "tools.filtering.html",
    "href": "tools.filtering.html",
    "title": "Filtering",
    "section": "",
    "text": "with open('../data/libraries/PAINS_alerts.json') as f:\n    alerts_dict = json.load(f)['structural_alerts']\n    structural_alerts = alerts_dict.get('structural_alerts', None)\n\n\nab=MolFiltering.from_df(data,'smiles', alerts_dict)\nab\n\n\n\n\n\n\n    \n      \n      100.00% [500/500 00:43<00:00]\n    \n    \n\n\n\n\n\n\n  \n    \n      \n      _smiles\n      Alert_SMARTS\n      Alert_description\n      Alert_rule_set\n      Alert_num_hits\n    \n  \n  \n    \n      0\n      N#CC(C#N)=C(C#N)c1cc(O)cc(O)c1\n      [#6](-[#6]#[#7])(-[#6]#[#7])=[#6]-c:1:c:c:c:c:c:1\n      ene_cyano_A(19)\n      PAINS\n      1\n    \n    \n      0\n      COc1cc(C=C(C#N)C#N)cc(CSCC(=O)O)c1O\n      [#6](-[#6]#[#7])(-[#6]#[#7])=[#6]-c:1:c:c:c:c:c:1\n      ene_cyano_A(19)\n      PAINS\n      1\n    \n    \n      0\n      O=C(Nc1ccccc1)N(Cc1ccc(F)cc1)Cc1cc(Cl)cc(Cl)c1O\n      [#7]-[C;X4]-c1ccccc1-[O;H1]\n      mannich_A(296)\n      PAINS\n      1\n    \n    \n      0\n      COc1ccc(/C=C2\\CCC/C(=C\\c3cc(OC)cc(OC)c3)C2=O)cc1\n      [#6]=!@[#6](-[!#1])-@[#6](=!@[!#6&!#1])-@[#6](...\n      ene_one_ene_A(57)\n      PAINS\n      1\n    \n    \n      0\n      C=COC(=O)N(CCN(C)C)/N=N/c1ccc2ncnc(Nc3cccc(Cl)...\n      [#7;!R]=[#7]\n      azo_A(324)\n      PAINS\n      1\n    \n    \n      0\n      N#CC(C#N)=Cc1cc2c(cc1[N+](=O)[O-])OCO2\n      [#6](-[#6]#[#7])(-[#6]#[#7])=[#6]-c:1:c:c:c:c:c:1\n      ene_cyano_A(19)\n      PAINS\n      1\n    \n    \n      0\n      COc1cc(C=C(C#N)C#N)cc(CSc2ccccc2)c1O\n      [#6](-[#6]#[#7])(-[#6]#[#7])=[#6]-c:1:c:c:c:c:c:1\n      ene_cyano_A(19)\n      PAINS\n      1\n    \n    \n      0\n      C/N=N/Nc1ccc2ncnc(Nc3cccc(Br)c3)c2c1\n      [#7;!R]=[#7]\n      azo_A(324)\n      PAINS\n      1\n    \n    \n      0\n      COc1cc(C=C(C#N)C#N)cc(OC)c1O\n      [#6](-[#6]#[#7])(-[#6]#[#7])=[#6]-c:1:c:c:c:c:c:1\n      ene_cyano_A(19)\n      PAINS\n      1\n    \n    \n      0\n      Oc1cc2cc(-c3cccnc3)cnc2cc1O\n      c:1:c:c(:c(:c:c:1)-[#8;H1])-[#8;H1]\n      catechol_A(92)\n      PAINS\n      1\n    \n    \n      0\n      COc1cc(/C=C2\\CCC/C(=C\\c3ccccc3OC)C2=O)cc(OC)c1\n      [#6]=!@[#6](-[!#1])-@[#6](=!@[!#6&!#1])-@[#6](...\n      ene_one_ene_A(57)\n      PAINS\n      1\n    \n    \n      0\n      N#CC(C#N)=Cc1ccc(/C=C/C(=O)O)cc1\n      [#6](-[#6]#[#7])(-[#6]#[#7])=[#6]-c:1:c:c:c:c:c:1\n      ene_cyano_A(19)\n      PAINS\n      1\n    \n    \n      0\n      Oc1cc2ncnc(Nc3cccc(Br)c3)c2cc1O\n      c:1:c:c(:c(:c:c:1)-[#8;H1])-[#8;H1]\n      catechol_A(92)\n      PAINS\n      1\n    \n    \n      0\n      CCN(C)[C@H]1C[C@@H]2O[C@](C)([C@H]1OC)n1c3cccc...\n      [#6]=,:[#6]:[#7]([#6])~[#6]:[#6]=,:[#6][#6]~[#...\n      dyes5A(27)\n      PAINS\n      4\n    \n    \n      0\n      CN(C)/N=N/c1ccc2ncnc(N(C)c3ccccc3)c2c1\n      [#7;!R]=[#7]\n      azo_A(324)\n      PAINS\n      1\n    \n    \n      0\n      COc1cc(C=C(C#N)C#N)cc(O)c1O\n      c:1:c:c(:c(:c:c:1)-[#8;H1])-[#8;H1]\n      catechol_A(92)\n      PAINS\n      1\n    \n    \n      1\n      COc1cc(C=C(C#N)C#N)cc(O)c1O\n      [#6](-[#6]#[#7])(-[#6]#[#7])=[#6]-c:1:c:c:c:c:c:1\n      ene_cyano_A(19)\n      PAINS\n      1\n    \n    \n      0\n      COc1cc(/C=C2\\CCC/C(=C\\C3CCCCC3)C2=O)cc(OC)c1\n      [#6]=!@[#6](-[!#1])-@[#6](=!@[!#6&!#1])-@[#6](...\n      ene_one_ene_A(57)\n      PAINS\n      1\n    \n    \n      0\n      CN(C)/N=N/c1ccc2ncnc(Nc3cccc(Br)c3)c2c1\n      [#7;!R]=[#7]\n      azo_A(324)\n      PAINS\n      1\n    \n    \n      0\n      N#C/C(=C\\c1cc(O)c(O)c(O)c1)C(=O)NCCCCNC(=O)/C(...\n      c:1:c:c(:c(:c:c:1)-[#8;H1])-[#8;H1]\n      catechol_A(92)\n      PAINS\n      4\n    \n    \n      0\n      CN(CCCl)CCN/N=N/c1ccc2ncnc(Nc3cccc(Cl)c3)c2c1\n      [#7;!R]=[#7]\n      azo_A(324)\n      PAINS\n      1\n    \n    \n      0\n      N#CC(C#N)=Cc1cc(O)ccc1[N+](=O)[O-]\n      [#6](-[#6]#[#7])(-[#6]#[#7])=[#6]-c:1:c:c:c:c:c:1\n      ene_cyano_A(19)\n      PAINS\n      1\n    \n    \n      0\n      Oc1ccccc1O\n      c:1:c:c(:c(:c:c:1)-[#8;H1])-[#8;H1]\n      catechol_A(92)\n      PAINS\n      1\n    \n    \n      0\n      COc1cc(C=C(C#N)C#N)ccc1O\n      [#6](-[#6]#[#7])(-[#6]#[#7])=[#6]-c:1:c:c:c:c:c:1\n      ene_cyano_A(19)\n      PAINS\n      1\n    \n    \n      0\n      Oc1cc(O)c2cc(O)c(-c3cc(O)c(O)c(O)c3)[o+]c2c1.[...\n      c:1:c:c(:c(:c:c:1)-[#8;H1])-[#8;H1]\n      catechol_A(92)\n      PAINS\n      2\n    \n    \n      0\n      N#C/C(=C\\c1cc(O)c(O)c(Br)c1)S(=O)(=O)/C(C#N)=C...\n      c:1:c:c(:c(:c:c:1)-[#8;H1])-[#8;H1]\n      catechol_A(92)\n      PAINS\n      2\n    \n    \n      0\n      CC(C)n1nc(-c2ccc3c(ccn3C(=O)OC(C)(C)C)c2)c2c(N...\n      [#6]=,:[#6]:[#7]([#6])~[#6]:[#6]=,:[#6][#6]~[#...\n      dyes5A(27)\n      PAINS\n      2\n    \n  \n\n\n\n\n\nsource\n\nMolFiltering\n\n MolFiltering ()\n\nFilter a molecular dataset from unwanted structures\nUse factory methods MolFiltering.from_list, MolFiltering.from_df or MolFiltering.from_csv instead of accessing the class directly.\n\nsource\n\n\nMolFiltering.from_df\n\n MolFiltering.from_df (df:pandas.core.frame.DataFrame, smiles_col:str,\n                       alerts_dict:dict=None, n_jobs:int=1)\n\nFactory method to process a pandas.DataFrame\nArguments:\ndf : pd.DataFrame\n    A pandas Dataframe with molecular data for sanitization.\n\nsmiles_col : str\n    The name of the column with SMILES for each molecule.\nReturns:\nalerts_df : `pandas.DataFrame`\n\n    A `pandas.DataFrames` with flagged molecules.\n\nsource\n\n\nMolFiltering.from_csv\n\n MolFiltering.from_csv (data_path:str, smiles_col:str,\n                        alerts_dict:dict=None, n_jobs:int=1, sep:str=',')\n\nFactory method to process a CSV file.\nArguments:\ndata_path : str\n    Path to CSV file\n\nsmiles_col : str\n    The name of the column with SMILES for each molecule.\nReturns:\nalerts_df : `pandas.DataFrame`\n\n    A `pandas.DataFrames` with flagged molecules.\n\nsource\n\n\nMolFiltering.from_list\n\n MolFiltering.from_list (smiles_list, alerts_dict:dict=None, n_jobs:int=1,\n                         **kwargs)\n\nFactory method to process a list of SMILES.\nArguments:\nsmiles : A List, Array, or any Iterable (except strings)\n    SMILES ready for sanitization\nReturns:\nalerts_df : `pandas.DataFrame`\n\n    A `pandas.DataFrames` with flagged molecules."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "chemtools",
    "section": "",
    "text": "Standardization\nA dataset of molecules can be standardize in just 1 line of code!\n\nimport pandas as pd\nimport numpy as np\nfrom chemtools.tools.sanitizer import MolCleaner\nfrom chemtools.tools.featurizer import MolFeaturizer\nfrom chemtools.tools.filtering import MolFiltering\nfrom rdkit import Chem\nimport json\n\n\ndata = pd.read_csv('../data/example_data.csv')\n\n\n\nSanitizing\nThe MolCleaner class performs sanitization tasks, including:\n    1. Standardize unknown stereochemistry (Handled by the RDKit Mol file parser)\n        i) Fix wiggly bonds on sp3 carbons - sets atoms and bonds marked as unknown stereo to no stereo\n        ii) Fix wiggly bonds on double bonds – set double bond to crossed bond\n    2. Clears S Group data from the mol file\n    3. Kekulize the structure\n    4. Remove H atoms (See the page on explicit Hs for more details)\n    5. Normalization:\n        Fix hypervalent nitro groups\n        Fix KO to K+ O- and NaO to Na+ O- (Also add Li+ to this)\n        Correct amides with N=COH\n        Standardise sulphoxides to charge separated form\n        Standardize diazonium N (atom :2 here: [*:1]-[N;X2:2]#[N;X1:3]>>[*:1]) to N+\n        Ensure quaternary N is charged\n        Ensure trivalent O ([*:1]=[O;X2;v3;+0:2]-[#6:3]) is charged\n        Ensure trivalent S ([O:1]=[S;D2;+0:2]-[#6:3]) is charged\n        Ensure halogen with no neighbors ([F,Cl,Br,I;X0;+0:1]) is charged\n    6. The molecule is neutralized, if possible. See the page on neutralization rules for more details.\n    7. Remove stereo from tartrate to simplify salt matching\n    8. Normalise (straighten) triple bonds and allenes\n    \n    \n    \n    The curation steps in ChEMBL structure pipeline were augmented with additional steps to identify duplicated entries\n    9. Find stereo centers\n    10. Generate inchi keys\n    11. Find duplicated SMILES. If the same SMILES is present multiple times, two outcomes are possible.\n        i. The same compound (e.g. same ID and same SMILES)\n        ii. Isomers with different SMILES, IDs and/or activities\n        \n        In case i), the compounds are merged by taking the median values of all numeric columns in the dataframe. \n        For case ii), the compounds are further classified as 'to merge' or 'to keep' depending on the activity values.\n            a) Compounds are considered for mergining (to merge) if the difference in acvitities is less than 1log unit.\n            b) Compounds are considered for keeping as individual entries (to keep) if the difference in activities is larger than 1log unit. In this case, the user can\n            select which compound to keep - the one with highest or lowest activity.\n\nprocessed_data = MolCleaner.from_df(data, smiles_col='smiles', act_col='pIC50', id_col='molecule_chembl_id')\n\n\n\n+------------------------------------------------------------+-------------------------------------------------------------+\n|                      processed_smiles                      |                           smiles                            |\n+============================================================+=============================================================+\n|      N#Cc1cnc(Nc2cccc(Br)c2)c2cc(NC(=O)c3ccco3)ccc12       |       N#Cc1cnc(Nc2cccc(Br)c2)c2cc(NC(=O)c3ccco3)ccc12       |\n+------------------------------------------------------------+-------------------------------------------------------------+\n|      COc1cccc(-c2cn(-c3ccc(CNCCO)cc3)c3ncnc(N)c23)c1       |       COc1cccc(-c2cn(-c3ccc(CNCCO)cc3)c3ncnc(N)c23)c1       |\n+------------------------------------------------------------+-------------------------------------------------------------+\n| Cc1ncc([N+](=O)[O-])n1CC(=NNC(=O)c1ccc(O)cc1)c1ccc(Br)cc1  | Cc1ncc([N+](=O)[O-])n1C/C(=N/NC(=O)c1ccc(O)cc1)c1ccc(Br)cc1 |\n+------------------------------------------------------------+-------------------------------------------------------------+\n|               C1CCC(C(CC2CCCCN2)C2CCCCC2)CC1               |               C1CCC(C(CC2CCCCN2)C2CCCCC2)CC1                |\n+------------------------------------------------------------+-------------------------------------------------------------+\n| Cc1cc2cc(Nc3ccnc4cc(-c5ccc(CNCCN6CCNCC6)cc5)sc34)ccc2[nH]1 | Cc1cc2cc(Nc3ccnc4cc(-c5ccc(CNCCN6CCNCC6)cc5)sc34)ccc2[nH]1  |\n+------------------------------------------------------------+-------------------------------------------------------------+\n\n\n\n\nFiltering\nThe MolFiltering class is responsible for removing compounds that match defined substructural alerts, including PAINS and rules defined by different organizations, such as GSK and University of Dundee.\n\nwith open('../data/libraries/Glaxo_alerts.json') as f:\n    alerts_dict = json.load(f)['structural_alerts']\n    structural_alerts = alerts_dict.get('structural_alerts', None)\n\n\nalerts_data = MolFiltering.from_df(processed_data, smiles_col='processed_smiles', alerts_dict=alerts_dict)\n\n\n\n+----------------------------------------------------------------------------+-----------------------+---------------------------+------------------+------------------+\n|                                  _smiles                                   |     Alert_SMARTS      |     Alert_description     |  Alert_rule_set  |   Alert_num_hits |\n+============================================================================+=======================+===========================+==================+==================+\n|         Cc1ncc([N+](=O)[O-])n1CC(=NNC(=O)c1ccc(O)cc1)c1ccc(Br)cc1          |   [N;R0][N;R0]C(=O)   |     R17 acylhydrazide     |      Glaxo       |                1 |\n+----------------------------------------------------------------------------+-----------------------+---------------------------+------------------+------------------+\n|               O=NN(CCCl)C(=O)Nc1ccc2ncnc(Nc3cccc(Cl)c3)c2c1                | [Br,Cl,I][CX4;CH,CH2] | R1 Reactive alkyl halides |      Glaxo       |                1 |\n+----------------------------------------------------------------------------+-----------------------+---------------------------+------------------+------------------+\n|               O=NN(CCCl)C(=O)Nc1ccc2ncnc(Nc3cccc(Cl)c3)c2c1                |   [N;R0][N;R0]C(=O)   |     R17 acylhydrazide     |      Glaxo       |                1 |\n+----------------------------------------------------------------------------+-----------------------+---------------------------+------------------+------------------+\n|               O=NN(CCCl)C(=O)Nc1ccc2ncnc(Nc3cccc(Cl)c3)c2c1                |      [N&D2](=O)       |        R21 Nitroso        |      Glaxo       |                1 |\n+----------------------------------------------------------------------------+-----------------------+---------------------------+------------------+------------------+\n| CS(=O)(=O)O[C@H]1CN[C@H](C#Cc2cc3ncnc(Nc4ccc(OCc5cccc(F)c5)c(Cl)c4)c3s2)C1 |   COS(=O)(=O)[C,c]    |      R5 Sulphonates       |      Glaxo       |                1 |\n+----------------------------------------------------------------------------+-----------------------+---------------------------+------------------+------------------+\n\n\n\nQuinone\n\nmol = Chem.MolFromSmiles('COC1/C=C\\OC2(C)Oc3c(C)c(O)c4c(c3C2=O)C(=O)C=C(NC(=O)/C(C)=C\\C=C/C(C)C(O)C(C)C(O)C(C)C(OC(C)=O)C1C)C4=O')\nmol.GetSubstructMatches(Chem.MolFromSmarts('O=C1[#6]~[#6]C(=O)[#6]~[#6]1'))\nmol\n\n\n\n\n\n\nCynamide\n\nmol1 = Chem.MolFromSmiles('Cc1cccc(C[C@H](NC(=O)c2cc(C(C)(C)C)nn2C)C(=O)NCC#N)c1')\nmol1.GetSubstructMatches(Chem.MolFromSmarts('N[CH2]C#N'))\nmol1\n\n\n\n\n\n\nR18 Quaternary C, Cl, I, P or S\n\nmol = Chem.MolFromSmiles('CC[C@H](NC(=O)c1c([S+](C)[O-])c(-c2ccccc2)nc2ccccc12)c1ccccc1')\nmol.GetSubstructMatches(Chem.MolFromSmarts('[C+,Cl+,I+,P+,S+]'))\nmol\n\n\n\n\n\n\n\nFeaturization\nThe MolFeaturizer class converts SMILES into molecular descriptors. The current version supports Morgan fingerprints, Atom Pairs, Torsion Fingerprints, RDKit fingerprints and 200 constitutional descriptors, and MACCS keys.\n\nfingerprinter = MolFeaturizer('morgan')\n\n\nX = fingerprinter.process_smiles_list(processed_data['processed_smiles'].values)\n\n\nX[0:5]\n\narray([[0, 0, 0, ..., 0, 0, 0],\n       [0, 0, 0, ..., 0, 0, 0],\n       [0, 0, 0, ..., 0, 0, 0],\n       [0, 1, 1, ..., 0, 0, 0],\n       [0, 0, 0, ..., 0, 0, 1]], dtype=uint8)"
  },
  {
    "objectID": "tools.sanitizer.html",
    "href": "tools.sanitizer.html",
    "title": "Standardizer",
    "section": "",
    "text": "source\n\n\n\n find_inchikey_duplicates (mol_list)\n\n\nsource\n\n\n\n\n build_inchi_dict (smiles_list)\n\n\nsource\n\n\n\n\n mol_to_inchi (mol)\n\nConverts a rdchem.Mol object into InCHI keys\n\nsource\n\n\n\n\n process_duplicates (data, smiles_col:str, act_col:str, id_col:str,\n                     cols_to_check:list=None, stereo_col:str='Stereo',\n                     keep:str='first')\n\nRemoves duplicated records from a dataset\nThe removal of duplicates is based on the stereochemical information provided by dotmatics, SMILES, ids and bioactivity records. Records sharing the same SMILES, IDs and/or bioactivity information, are merged by taking the median bioactivity value. This step is used to clean records with multiple measurements.\nDuplicated records with different IDs and/or bioactivities are treated separately because they usually represent different isomers. For these compounds, the duplicated records are first split into to_merge and to_keep portions, indicating the different compounds should be considered to be kept in the dataset or merged into the same record, respectively. Duplicated records are considered for keeping, if the difference between max and min bioactivity is larger or equal to 1.0 (e.g. 1 pIC50 unit); else the records are considered for merging.\nCompounds marked for keeping filtered by the keep parameter. If keep == True, the duplicate with highest bioactivity value is kept; else the duplicate with lowest bioactivity is kept. Compounds marked for merging are combined by taking the median of all columns.\nArguments:\n    data : pd.DataFrame\n        A pandas Dataframe with molecular data for sanitization.\n\n    smiles_col : str\n        The name of the column with SMILES for each molecule.\n\n    id_col : str\n        The name of the column with IDs for each molecule.\n\n    act_col : str\n        The name of the column with bioactivity data for each molecule. \n\n    cols_to_check : list\n        A list of columns to use as reference to find duplicates.\n\nReturns:\n    recombined_data : `pandas.DataFrame`\n\n        A sanitized version of the `data` without duplicates.\n\nsource\n\n\n\n\n remove_racemic (df, smiles_col, stereo_col)\n\nRemove records containing Mixture or Racemic information in the stereochemistry column from Dotmatics Compounds are only removed if the SMILES are duplicated and single isomer is also present.\nArguments:\ndf : `pandas.DataFrame`\n\n    A pandas dataframe.\n\nsmiles_col : str\n\n    A string representing the column of `df` with SMILES.\n\nstereo_col : str\n\n    A string representing the column of `df` with stereochemistry information for each molecule.          \nReturns: A list of columns with modifier values\n\nsource\n\n\n\n\n get_stereo_info (mol)\n\n\nsource\n\n\n\n\n normalize_mol (mol)\n\nStandardize a rdchem.Mol object\nSee https://github.com/chembl/ChEMBL_Structure_Pipeline/wiki/Work-done-by-each-step#standardize_molblock for details on the normalization steps\n\nsource\n\n\n\n\n get_mixture (mol)\n\nFind mixtures of compounds in a rdchem.Mol object If a mixture is present, returns None\n\nsource\n\n\n\n\n remove_unwanted (mol)\n\nRemove molecules with unwanted elements (check the _unwanted definition) and isotopes\n\nsource\n\n\n\n\n getlargestfragment (mol)\n\nGet largest fragments in a molecule\n\nsource\n\n\n\n\n add_nitrogen_charges (mol)\n\nFixes charge on nitrogen if its valence raises an Exception on RDKit See the discussion on: https://github.com/rdkit/rdkit/issues/3310"
  },
  {
    "objectID": "tools.sanitizer.html#molcleaner",
    "href": "tools.sanitizer.html#molcleaner",
    "title": "Standardizer",
    "section": "MolCleaner",
    "text": "MolCleaner\n\nsource\n\nMolCleaner\n\n MolCleaner (ids=None, smiles=None)\n\nSanitize a molecular dataset\nUse static methods `MolCleaner.from_df or MolCleaner.from_csv` instead of accessing the         class directly.\n\nThe sanitization process follows the steps implemented in the `chembl_structure_pipeline` package         (https://github.com/chembl/ChEMBL_Structure_Pipeline)\n\n1. Standardize unknown stereochemistry (Handled by the RDKit Mol file parser)\n    i) Fix wiggly bonds on sp3 carbons - sets atoms and bonds marked as unknown stereo to no stereo\n    ii) Fix wiggly bonds on double bonds – set double bond to crossed bond\n2. Clears S Group data from the mol file\n3. Kekulize the structure\n4. Remove H atoms (See the page on explicit Hs for more details)\n5. Normalization:\n    Fix hypervalent nitro groups\n    Fix KO to K+ O- and NaO to Na+ O- (Also add Li+ to this)\n    Correct amides with N=COH\n    Standardise sulphoxides to charge separated form\n    Standardize diazonium N (atom :2 here: [*:1]-[N;X2:2]#[N;X1:3]>>[*:1]) to N+\n    Ensure quaternary N is charged\n    Ensure trivalent O ([*:1]=[O;X2;v3;+0:2]-[#6:3]) is charged\n    Ensure trivalent S ([O:1]=[S;D2;+0:2]-[#6:3]) is charged\n    Ensure halogen with no neighbors ([F,Cl,Br,I;X0;+0:1]) is charged\n6. The molecule is neutralized, if possible. See the page on neutralization rules for more details.\n7. Remove stereo from tartrate to simplify salt matching\n8. Normalise (straighten) triple bonds and allenes\n\nThe curation steps in ChEMBL structure pipeline were augmented with additional steps to identify duplicated entries\n9. Find stereo centers\n10. Generate inchi keys\n11. Find duplicated SMILES. If the same SMILES is present multiple times, two outcomes are possible.\n    i. The same compound (e.g. same ID and same SMILES)\n    ii. Isomers with different SMILES, IDs and/or activities\n\n    In case i), the compounds are merged by taking the median values of all numeric columns in the dataframe. \n    For case ii), the compounds are further classified as 'to merge' or 'to keep' depending on the activity values.\n        a) Compounds are considered for mergining (to merge) if the difference in acvitities is less than 1log unit.\n        b) Compounds are considered for keeping as individual entries (to keep) if the difference in activities is larger than 1log unit. In this case, the user can\n        select which compound to keep - the one with highest or lowest activity.\nParameters:\nids : array-like\n    An array of unique identifiers for molecules in a dataset.\n\nsmiles : array-like\n    An array of SMILES.\nAttributes:\nids : array-like\n    An array of unique identifiers for molecules in a dataset.\n\nsmiles : array-like\n    An array of SMILES.\n\ndata : sanitized_data\n    Sanitized dataset\n\nsmiles_col : str\n    A string representing the column of `data` with SMILES.\n\nid_col : str\n    A string representing the column of `data` with IDs for each molecule."
  },
  {
    "objectID": "utils.html",
    "href": "utils.html",
    "title": "Utils",
    "section": "",
    "text": "source\n\nconvert_smiles\n\n convert_smiles (mol, sanitize=False)"
  },
  {
    "objectID": "tools.featurizer.html",
    "href": "tools.featurizer.html",
    "title": "Featurizer",
    "section": "",
    "text": "MolFeaturizer\n\nsource\n\nMolFeaturizer\n\n MolFeaturizer (descriptor_type:str, params:dict={})\n\nCreates a Fingerprinter to perform molecular featurization\nAttributes:\nparams : dict, optional\n    A dictionary of parameters for an rdkit generator.\n\ndescriptor_type : str\n    A string representing a descriptor available in ´rdFingerprintGenerator´\n\ngenerator : \n    A fingerprinter generator available in ´rdFingerprintGenerator´\nArguments:\ndescriptor_type : str\n    A string representing a descriptor available in ´rdFingerprintGenerator´\n\nparams : dict, optional\n    A dictionary of parameters for an rdkit generator.\n\nsource\n\n\nMolFeaturizer.process_smiles\n\n MolFeaturizer.process_smiles (smi, use_counts:bool=False)\n\nGenerate features for one SMILES.\nArguments:\nsmi : str\n    A SMILES representing a molecular structure\n\nuse_counts : bool (default=False)\n    Whether to consider feature's counts for fingerprint generation.\n\nsource\n\n\nMolFeaturizer.process_smiles_list\n\n MolFeaturizer.process_smiles_list (smiles_list:List[str], **kwargs)\n\nGenerate features for a list of SMILES.\nArguments:\nsmiles_list : List[str]\n    A list of SMILES.\nKeyword arguments:\nuse_counts : bool (default=False)\n    Whether to consider feature's counts for fingerprint generation."
  }
]