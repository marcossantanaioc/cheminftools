# AUTOGENERATED! DO NOT EDIT! File to edit: ../../notebooks/sanitizer.ipynb.

# %% auto 0
__all__ = ['mol_to_inchi', 'build_inchi_dict', 'find_inchikey_duplicates', 'add_nitrogen_charges', 'getlargestfragment',
           'remove_unwanted', 'get_mixture', 'normalize_mol', 'get_stereo_info', 'remove_racemic', 'process_duplicates',
           'MolCleaner']

# %% ../../notebooks/sanitizer.ipynb 2
import pandas as pd
import numpy as np

import multiprocessing as mp
from ..utils import convert_smiles
from rdkit import Chem, rdBase
from rdkit.Chem import rdchem, rdmolops, SanitizeMol
from rdkit.Chem.FilterCatalog import *
from rdkit.Chem.MolStandardize.rdMolStandardize import LargestFragmentChooser
from rdkit.Chem.SaltRemover import SaltRemover

from rdkit.Chem.MolStandardize import rdMolStandardize

from fastprogress.fastprogress import master_bar, progress_bar
from time import sleep

from rdkit import RDLogger                                                                                                                                                               
RDLogger.DisableLog('rdApp.*')   

# %% ../../notebooks/sanitizer.ipynb 6
rdBase.DisableLog('rdApp.error')
rdBase.DisableLog('rdApp.info')
_saltremover = SaltRemover()
_unwanted = Chem.MolFromSmarts('[!#1!#5!#6!#7!#8!#9!#15!#16!#17!#35!#53]')

# %% ../../notebooks/sanitizer.ipynb 7
def mol_to_inchi(mol):
    """Converts a rdchem.Mol object into InCHI keys"""
    mol = convert_smiles(mol, sanitize=True)
    inchi = Chem.MolToInchiKey(mol)
    return inchi   

def build_inchi_dict(smiles_list):
    if smiles_list is None:
        print("Please provide a valid list of molecules")
    inchi_dict = {mol_to_inchi(smi):smi for smi in smiles_list}
    return inchi_dict

def find_inchikey_duplicates(mol_list):
    from collections import Counter
    
    """Analyze a list of rdkit.Mol and identify InChIKey with more than molecule.

    Arguments:
        mol_list : List rdkit.Mol objects to analyze

    Returns:
        duplis : List of duplicates
    """
    
    inchi_dict = build_inchi_dict(mol_list)
    inchi_key_list = [mol_to_inchi(mol) for mol in mol_list]
    
    if len(inchi_key_list) == len(set(inchi_key_list)):
        return {}

    counts = dict(Counter(inchi_key_list))
    duplis = [inchi_dict[inchi] for inchi in inchi_dict.keys() if counts[inchi]>1]
    return duplis

# %% ../../notebooks/sanitizer.ipynb 8
def add_nitrogen_charges(mol):
    """Fixes charge on nitrogen if its valence raises an Exception on RDKit
    See the discussion on: https://github.com/rdkit/rdkit/issues/3310
    """

    mol.UpdatePropertyCache(strict=False)
    ps = Chem.DetectChemistryProblems(mol)
    if not ps:
        Chem.SanitizeMol(mol)
        return mol
    for p in ps:
        if p.GetType() == 'AtomValenceException':
            at = mol.GetAtomWithIdx(p.GetAtomIdx())
            if at.GetAtomicNum() == 7 and at.GetFormalCharge() == 0 and at.GetExplicitValence() == 4:
                at.SetFormalCharge(1)
    Chem.SanitizeMol(mol)
    return mol


def getlargestfragment(mol):
    """Get largest fragments in a molecule"""
    frags = rdmolops.GetMolFrags(mol, asMols=True, sanitizeFrags=True)

    frag_size = ((idx, m.GetNumHeavyAtoms()) for idx, m in enumerate(frags) if
                 m.GetNumHeavyAtoms() >= 6 and Chem.rdMolDescriptors.CalcNumRings(m) >= 1)
    maxmol = sorted(frag_size, key=lambda x: x[1], reverse=True)[0][0]
    return frags[maxmol]


def remove_unwanted(mol):
    """Remove molecules with unwanted elements (check the _unwanted definition) and isotopes"""
    if not mol.HasSubstructMatch(_unwanted) and (sum([atom.GetIsotope() for atom in mol.GetAtoms()]) == 0):
        return mol


def get_mixture(mol):
    """Find mixtures of compounds in a rdchem.Mol object \
    If a mixture is present, returns None

    """
    frags = rdmolops.GetMolFrags(mol, asMols=True, sanitizeFrags=True)
    if len(frags) == 1:
        return frags[0]
    else:
        return None


def normalize_mol(mol):
    """Standardize a rdchem.Mol object

    See https://github.com/chembl/ChEMBL_Structure_Pipeline/wiki/Work-done-by-each-step#standardize_molblock
    for details on the normalization steps

    """
    mol = convert_smiles(mol, sanitize=False)
    patt = Chem.MolFromSmarts('[O-]N(=O)')  # Corrects nitro groups from Dotmatics
    if mol.HasSubstructMatch(patt):
        mol = add_nitrogen_charges(mol)
    
    # removeHs, disconnect metal atoms, normalize the molecule, reionize the molecule
    clean_mol = rdMolStandardize.Cleanup(mol) 
     
    # if many fragments, get the "parent" (the actual mol we are interested in) 
    parent_clean_mol = rdMolStandardize.FragmentParent(clean_mol)
         
    # try to neutralize molecule
    uncharger = rdMolStandardize.Uncharger() # annoying, but necessary as no convenience method exists
    uncharged_parent_clean_mol = uncharger.uncharge(parent_clean_mol)
     
    # note that no attempt is made at reionization at this step
    # nor at ionization at some pH (rdkit has no pKa caculator)
    # the main aim to to represent all molecules from different sources
    # in a (single) standard way, for use in ML, catalogue, etc.
     
    te = rdMolStandardize.TautomerEnumerator() # idem
    taut_uncharged_parent_clean_mol = te.Canonicalize(uncharged_parent_clean_mol)
     
    return taut_uncharged_parent_clean_mol


def get_stereo_info(mol):
    try:
        stereo = Chem.FindMolChiralCenters(convert_smiles(mol,sanitize=True),force=True,includeUnassigned=True,useLegacyImplementation=False)
    except RuntimeError as error:
        print(error)
        stereo = 'Stereo not calculated'
    centers =[]
    for center in stereo:
        st = '_'.join(map(str, center))
        centers.append(st)
    return '|'.join(centers)

def remove_racemic(df, smiles_col, stereo_col):    
    
    """    
    Remove records containing Mixture or Racemic information in the stereochemistry column from Dotmatics
    Compounds are only removed if the SMILES are duplicated and single isomer is also present.
    
    Arguments:
    
        df : `pandas.DataFrame`
        
            A pandas dataframe.
            
        smiles_col : str
        
            A string representing the column of `df` with SMILES.

        stereo_col : str
        
            A string representing the column of `df` with stereochemistry information for each molecule.          
    
    Returns:
        A list of columns with modifier values
        
    """
    m1 = df[smiles_col].duplicated(keep=False)
    m2 = (df[stereo_col].str.contains('|'.join(['Mixture',
                                                'mixture',
                                                'Racemic', 
                                                'racemic',
                                                'diasteroisomeric',
                                                'Diasteroisomeric'])))

    no_racemic = df[~(m1 & m2)]
    no_racemic.reset_index(drop=True, inplace=True)
    return no_racemic


def process_duplicates(data, smiles_col:str, act_col:str, id_col:str, cols_to_check:list=None, stereo_col:str='Stereo', keep:str='first'):
    """
    Removes duplicated records from a dataset
    
    The removal of duplicates is based on the stereochemical information provided by dotmatics, SMILES, ids and bioactivity records.
    Records sharing the same SMILES, IDs and/or bioactivity information, are merged by taking the median bioactivity value. 
    This step is used to clean records with multiple measurements.
    
    Duplicated records with different IDs and/or bioactivities are treated separately because they usually represent different isomers. 
    For these compounds, the duplicated records are first split into `to_merge` and `to_keep` portions, indicating the different compounds
    should be considered to be kept in the dataset or merged into the same record, respectively. Duplicated records are considered for keeping,
    if the difference between max and min bioactivity is larger or equal to 1.0 (e.g. 1 pIC50 unit); else the records are considered for merging.
    
    Compounds marked for keeping filtered by the `keep` parameter. If `keep == True`, the duplicate with highest bioactivity value is kept; else the duplicate with lowest bioactivity is kept.
    Compounds marked for merging are combined by taking the median of all columns.
    
    Arguments:
    

            data : pd.DataFrame
                A pandas Dataframe with molecular data for sanitization.

            smiles_col : str
                The name of the column with SMILES for each molecule.

            id_col : str
                The name of the column with IDs for each molecule.
                
            act_col : str
                The name of the column with bioactivity data for each molecule. 
                
                
            cols_to_check : list
                A list of columns to use as reference to find duplicates.
                

        Returns:
            recombined_data : `pandas.DataFrame`

                A sanitized version of the `data` without duplicates.   
    
    
    
    """
    assert keep in ['first','last']
    data = data.copy()   
    stereo_col = 'Stereo'
    
    # Convert to Inchi
    data['inchi'] = data[smiles_col].apply(mol_to_inchi)
    data[stereo_col] = data[smiles_col].apply(lambda x : get_stereo_info(x))
    #data = remove_racemic(df=data, smiles_col=smiles_col,stereo_col=stereo_col)
    
    if cols_to_check:
        data['duplicate'] = data.duplicated(subset=['inchi']+cols_to_check, keep=False).astype(bool)
    else: 
        data['duplicate'] = data.duplicated(subset=['inchi'], keep=False).astype(bool)
    duplicates = data[data['duplicate']==True]
    no_duplicates = data[data['duplicate']==False]
    no_duplicates.reset_index(drop=True,inplace=True)
    
    if duplicates.empty == False:
        # Remove duplicates
        processed_duplicates = [] # List to keep processed duplicates 

        ### Same ID, same SMILES  
        duplis_grouped = duplicates.groupby([id_col, 'inchi'], as_index=False).median().reset_index(drop=True)
        duplis_grouped.reset_index(drop=True,inplace=True)
        duplicates.reset_index(drop=True,inplace=True)

        real_duplis_removed = duplis_grouped.merge(duplicates.drop_duplicates(subset=[id_col,
                                                                                        'inchi',
                                                                                        act_col],
                                                                                keep='first').reset_index(drop=True),
                                                 on=[id_col, 'inchi'],
                                                 how='outer', 
                                                 suffixes=('', '_DROP')).filter(regex='^(?!.*_DROP)')

        ### Different ID, same SMILES, same activity

        ### Different ID, same SMILES
        # Combine duplicates with same SMILES but different IDS and/or bioactivities
        groups = real_duplis_removed.groupby('inchi')[act_col].apply(lambda x : np.abs(np.max(x) - np.min(x))).reset_index().dropna(subset=[act_col])

        # Split duplicates by type. If the difference in bioactivities is > 1.0, the records should be kept; else the records will be merged
        to_keep = real_duplis_removed[real_duplis_removed['inchi'].isin(groups[groups[act_col].ge(1.0)]['inchi'].unique())].reset_index(drop=True)
        to_merge = real_duplis_removed[real_duplis_removed['inchi'].isin(groups[groups[act_col].lt(1.0)]['inchi'].unique())].reset_index(drop=True)

        if to_merge.empty == False:
            # Merging duplicates
            to_merge[id_col] = to_merge.groupby('inchi')[id_col].transform('first')

            to_merge_median = to_merge.groupby([id_col,'inchi'],as_index=False).median().reset_index(drop=True)

            # Recombine information to merged data
            duplis_merged = to_merge_median.merge(to_merge.drop_duplicates(subset=['inchi'],keep='first'), on=[id_col,'inchi'],how='outer', suffixes=('', '_DROP')).filter(regex='^(?!.*_DROP)')
            duplis_merged.reset_index(drop=True,inplace=True)
            processed_duplicates.append(duplis_merged)

        else:
            print('No duplicates to merge')


        # Keeping duplicates
        if to_keep.empty == False and keep == 'first':

            duplis_kept = to_keep.groupby('inchi', group_keys=False).apply(lambda x: x.loc[x[act_col].idxmax()]).copy().reset_index(drop=True)
            duplis_kept.reset_index(drop=True,inplace=True)
            processed_duplicates.append(duplis_kept)

        elif to_keep.empty == False and keep == 'last':
            duplis_kept = to_keep.groupby('inchi', group_keys=False).apply(lambda x: x.loc[x[act_col].idxmin()]).copy().reset_index(drop=True)
            duplis_kept.reset_index(drop=True,inplace=True)        
            processed_duplicates.append(duplis_kept)

        else:
            print('No duplicates to keep')
            
        # Recombine data
        return pd.concat([no_duplicates, *processed_duplicates],axis=0)

    else:
        return no_duplicates



# %% ../../notebooks/sanitizer.ipynb 10
class MolCleaner:
    
    """Sanitize a molecular dataset
    
        Use static methods `MolCleaner.from_df or MolCleaner.from_csv` instead of accessing the \
        class directly.

        The sanitization process follows the steps implemented in the `chembl_structure_pipeline` package \
        (https://github.com/chembl/ChEMBL_Structure_Pipeline)
        
        1. Standardize unknown stereochemistry (Handled by the RDKit Mol file parser)
            i) Fix wiggly bonds on sp3 carbons - sets atoms and bonds marked as unknown stereo to no stereo
            ii) Fix wiggly bonds on double bonds â€“ set double bond to crossed bond
        2. Clears S Group data from the mol file
        3. Kekulize the structure
        4. Remove H atoms (See the page on explicit Hs for more details)
        5. Normalization:
            Fix hypervalent nitro groups
            Fix KO to K+ O- and NaO to Na+ O- (Also add Li+ to this)
            Correct amides with N=COH
            Standardise sulphoxides to charge separated form
            Standardize diazonium N (atom :2 here: [*:1]-[N;X2:2]#[N;X1:3]>>[*:1]) to N+
            Ensure quaternary N is charged
            Ensure trivalent O ([*:1]=[O;X2;v3;+0:2]-[#6:3]) is charged
            Ensure trivalent S ([O:1]=[S;D2;+0:2]-[#6:3]) is charged
            Ensure halogen with no neighbors ([F,Cl,Br,I;X0;+0:1]) is charged
        6. The molecule is neutralized, if possible. See the page on neutralization rules for more details.
        7. Remove stereo from tartrate to simplify salt matching
        8. Normalise (straighten) triple bonds and allenes
        
        
        
        The curation steps in ChEMBL structure pipeline were augmented with additional steps to identify duplicated entries
        9. Find stereo centers
        10. Generate inchi keys
        11. Find duplicated SMILES. If the same SMILES is present multiple times, two outcomes are possible.
            i. The same compound (e.g. same ID and same SMILES)
            ii. Isomers with different SMILES, IDs and/or activities
            
            In case i), the compounds are merged by taking the median values of all numeric columns in the dataframe. 
            For case ii), the compounds are further classified as 'to merge' or 'to keep' depending on the activity values.
                a) Compounds are considered for mergining (to merge) if the difference in acvitities is less than 1log unit.
                b) Compounds are considered for keeping as individual entries (to keep) if the difference in activities is larger than 1log unit. In this case, the user can
                select which compound to keep - the one with highest or lowest activity.
        

    Parameters:
    
        ids : array-like
            An array of unique identifiers for molecules in a dataset.

        smiles : array-like
            An array of SMILES.
        
    Attributes:
    
        ids : array-like
            An array of unique identifiers for molecules in a dataset.

        smiles : array-like
            An array of SMILES.

        data : sanitized_data
            Sanitized dataset

        smiles_col : str
            A string representing the column of `data` with SMILES.

        id_col : str
            A string representing the column of `data` with IDs for each molecule.
       
    """
    def __init__(self, ids=None, smiles=None):


        self._ids = ids
        self._raw_smiles = smiles
        self._data = None
        self._id_col = None
        self._smiles_col = None
        self._act_col = None

    def __len__(self):
        return len(self._smiles)

    def __str__(self):
        return f'Raw dataset has {len(self.raw_smiles)} records\nThe first record is: {self.raw_smiles[0]}'

    def __getitem__(self, i):
        return self.raw_smiles[i]

    @property
    def data(self):
        return self._data

    @data.setter
    def data(self, i):
        self._data = i

    @property
    def raw_smiles(self):
        return self._raw_smiles

    @raw_smiles.setter
    def raw_smiles(self, i):
        self._raw_smiles = i

    @property
    def ids(self):
        return self._ids

    @ids.setter
    def ids(self, i):
        self._ids = i
        
    @property
    def act_col(self):
        return self._act_col

    @act_col.setter
    def act_col(self, i):
        self._act_col = i

    @property
    def id_col(self):
        return self._id_col

    @id_col.setter
    def id_col(self, i):
        self._id_col = i

    @property
    def smiles_col(self):
        return self._smiles_col

    @smiles_col.setter
    def smiles_col(self, i):
        self._smiles_col = i

    @classmethod
    def process_mol(cls, mol):
        """Fully process one molecule"""
        mol = convert_smiles(mol)
        try:
            # Remove salts and molecules with unwanted elements (See _unwanted definition above)
            mol = remove_unwanted(normalize_mol(mol))


            # Check if mixture is present - standard advice is to remove all mixtures
            mol = get_mixture(mol)

            if isinstance(mol, rdchem.Mol):
                return Chem.MolToSmiles(mol)
        except:
            return None

    @classmethod
    def process_smiles_list(cls,smiles_list):
        """Sanitize list of SMILES"""

        sanitized_smiles = map(cls.process_mol, tqdm(smiles_list, desc='Sanitizing SMILES', position=0, leave=True))

        return sanitized_smiles

    @classmethod
    def from_list(cls, smiles_list):
        
        """Factory method to process a collection of SMILES

        Arguments:

            smiles : A List, Array, or any Iterable (except strings)
                SMILES ready for sanitization

        Returns:
            processed_mols : `pandas.DataFrame`

                A sanitized version of the `df` including all molecules. If sanitization fails for a molecule, \
                the original SMILES is kept but `processed_smiles` field will be NaN

        """
        act_col = 'Target'
        id_col = 'ID'
        smiles_col = 'SMILES'

        df = pd.DataFrame({smiles_col:smiles_list, 
                           id_col:[f'mol{idx}' for idx in range(len(smiles_list))],
                          act_col:[None]})


        return cls.from_df(df, 
                           smiles_col=smiles_col,
                           id_col=id_col, 
                           act_col=act_col)


    @classmethod
    def from_df(cls,
                df: pd.DataFrame, 
                smiles_col: str,
                act_col: str,
                id_col: str,
                keep:str='first',
                        cols_to_check:list=None):
        
        """Factory method to process a `pandas.DataFrame`

        Arguments:

            df : pd.DataFrame
                A pandas Dataframe with molecular data for sanitization.

            smiles_col : str
                The name of the column with SMILES for each molecule.

            id_col : str
                The name of the column with IDs for each molecule. If None, generates random IDs.

        Returns:
            processed_mols : `pandas.DataFrame`

                A sanitized version of the `df` including all molecules. If sanitization fails for a molecule,
                the original SMILES is kept but `processed_smiles` field will be NaN

        """     
        

        
        cls.data = df.copy()
        cls.data.reset_index(drop=True,inplace=True)
        cls.id_col = id_col
        cls.smiles_col = smiles_col
        cls.act_col = act_col

        cls.data[id_col] = cls.data[id_col].astype(str)

        cls.ids, cls.raw_smiles = cls.data[[id_col, smiles_col]].values.T



        return cls.sanitize_dataset(smiles=cls.raw_smiles,
                                    id_col=cls.id_col,
                                    act_col=cls.act_col,
                                    keep=keep,
                                    cols_to_check=cols_to_check)

    @classmethod
    def from_csv(cls,
                 data_path: str,
                 smiles_col: str,
                 act_col:str,
                id_col: str,
                 sep: str = ',',
                keep:str='first',
                        cols_to_check:list=None):
        
        """Factory method to process a CSV file

        Arguments:

            data_path : str
                Path to CSV file

            smiles_col : str
                The name of the column with SMILES for each molecule.

            id_col : str
                The name of the column with IDs for each molecule. 
                
            id_col : str
                The name of the column with stereochemistry information for each molecule. 
 
        Returns:
            processed_mols : `pandas.DataFrame`
            

                A sanitized version of the `df` including all molecules. If sanitization fails for a molecule,
                the original SMILES is kept but `processed_smiles` field will be NaN       
        
        """
        return cls.from_df(pd.read_csv(data_path, sep=sep), 
                           smiles_col=smiles_col,
                           id_col=id_col, 
                           act_col=act_col,
                           keep=keep,
                           cols_to_check=cols_to_check)


    @classmethod
    def sanitize_dataset(cls,
                         smiles=None,
                         id_col:str=None,
                         smiles_col:str=None,
                         act_col:str=None,
                         keep:str=None,
                        cols_to_check:list=None):
        
        """Sanitize a dataset and returns ids, original SMILES and processed SMILES"""
        with mp.Pool() as mp_pool:

            sanitized_smiles = list(progress_bar(mp_pool.imap(cls.process_mol, cls.raw_smiles), total=len(cls.raw_smiles)))
                
 
            cls.data.insert(loc=1, column='processed_smiles', value=list(sanitized_smiles))


            cls.data.dropna(subset=['processed_smiles',cls.act_col],inplace=True)
            cls.data.reset_index(drop=True,inplace=True)

            # Remove duplicates
            cls.data = process_duplicates(cls.data,
                                            smiles_col='processed_smiles',
                                            act_col=cls.act_col,
                                            id_col=cls.id_col,cols_to_check=cols_to_check)

        return cls.data
